tribonacci 範例

```
0 0 1 1 2 4 7 13 24 ...
```

以函式表示：

```
tribonacci(n): 0 0 1 1 2 4 7 13 24 ...
```

tribonacci(0) = 0,
tribonacci(1) = 0,
tribonacci(2) = 1,
tribonacci(3) = 1,
tribonacci(4) = 2,
tribonacci(5) = 4,
tribonacci(6) = 7,
tribonacci(7) = 13,
tribonacci(8) = 24

觀察該數列可以找到說 $trib(n) = trib(n - 1) + trib(n - 2) + trib(n - 3)$，以 $trib(5) = 4$ 來說其樹狀結構會是下圖，

![tribonacci tree](images/tribonacci-tree.png.png)

$trib(0) = 0$ 和 $trib(1) = 0$ 與 $trib(2) = 1$ 是基本條件，也可以說是在樹狀上的終止條件。對於節點為 3 的值，可以從子樹的結果相加獲取，所以 $fib(3) = fib(2) + fib(1) + fib(0) = 1 + 0 + 0 = 1$。

該樹狀結構會是以遞迴方式由下往上傳遞值，那其複雜度又是如何 ?

以時間複雜度來看，每個節點都要花費時間，而樹的節點是 $3^n-1$

time：$O(3^n)$

以上圖來看，樹的高度為 $n$，從根節點往下的子節點會是 3 個，因此每個階層都會是乘以 3。

>執行演算法所需要耗費的時間成本

對於遞迴的結構，程式通常是以堆疊方式執行，樹的階層就是其複雜度

space：$O(n)$

>執行時所花費的記憶體空間成本


這邊也會看到子樹其實會有重複的問題，導致了效能低落。這邊可以使用動態規劃(Dynamic programming)，動態規劃其實是一種在其他問題中利用任何重疊的子問題來解決問題，以上圖來說計算 3 這個節點的 3 個子問題，如果可以在第一次解決該問題時儲存該訊息，遇到相同的子問題時可以直接獲取不必重複計算。

經過動態規劃剪枝後，其複雜度可以下降

time：$O(n)$

space：$O(n)$
