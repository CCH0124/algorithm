Given an array of integers `arr`, return *`true` if and only if it is a valid mountain array*.

Recall that arr is a mountain array if and only if:

- `arr.length >= 3`
- There exists some `i` with `0 < i < arr.length - 1` such that:
  - `arr[0] < arr[1] < ... < arr[i - 1] < arr[i]`
  - `arr[i] > arr[i + 1] > ... > arr[arr.length - 1]`

![](https://assets.leetcode.com/uploads/2019/10/20/hint_valid_mountain_array.png)

##### Example 1:
```
Input: arr = [2,1]
Output: false
```
##### Example 2:
```
Input: arr = [3,5,5]
Output: false
```
##### Example 3:
```
Input: arr = [0,3,2,1]
Output: true
``` 

##### Constraints:

- `1 <= arr.length <= 104`
- `0 <= arr[i] <= 104`



使用 `while` 遍歷一開始的上坡是否符合，當遇到下坡時，記錄當下的位置，並在使用 `while` 遍歷下坡。
```java
class Solution {
    public boolean validMountainArray(int[] arr) {
        boolean up = false;
        boolean down = false;
        int i = 1;
        while (i < arr.length){
            if(arr[i] == arr[i-1]) {
                return false;
            } else if (arr[i] > arr[i-1]) {
                up = true;
            } else {
                break;
            }
            i++;
        }
        
        if (!up) return false;
        
        while(i < arr.length) {
            if(arr[i] == arr[i-1]) {
                return false;
            } else if (arr[i] < arr[i-1]) {
                down = true;
            } else {
                return false;
            }
            i++;
        }
        if (!down) return false;
        return true;
         
    }
}
```